<!DOCTYPE html>
<html>
  <head>
    <link type="text/css" rel="stylesheet" href="css/style.css"/>
    <style type="text/css">

#states path {
  fill: #ccc;
  stroke: #fff;
}

path.arc {
  pointer-events: none;
  fill: none;
  stroke: #000;
/* display: none; */
}

path.circuit {
  pointer-events: none;
  fill: none;
  stroke-width:2;
}

path.cell {
  fill: none;
  pointer-events: all;
}

path.circuits {
  fill: none;
  pointer-events: all;
}

circle {
  fill: steelblue;
  fill-opacity: .8;
  stroke: #fff;
}

#cells.voronoi path.cell {
  stroke: brown;
}

/*#cells g:hover path.arc {
  display: inherit;
  }*/

#cells path.arc {
  display: inherit;
}

#circuits path.arc {
  display: inherit;
  color: #0aa;
}

    </style>
  </head>
  <body>
    <h2>
      <span>Switches and Traffic</span><br>
    </h2>
    <!-- <div style="position:absolute;bottom:0;font-size:18px;">
      <input type="checkbox" id="voronoi"> <label for="voronoi">show Voronoi</label>
    </div> -->
    <script type="text/javascript" src="js/d3/d3.js"></script>
    <script type="text/javascript" src="js/d3/d3.csv.js"></script>
    <script type="text/javascript" src="js/d3/d3.geo.js"></script>
    <script type="text/javascript" src="js/d3/d3.geom.js"></script>
    <script type="text/javascript">

var w = 1280,
    h = 800;

var projection = d3.geo.azimuthal()
    .mode("equidistant")
    .origin([-98, 38])
    .scale(900)
    .translate([640, 360]);

var path = d3.geo.path()
    .projection(projection);

var svg = d3.select("body").insert("svg:svg", "h2")
    .attr("width", w)
    .attr("height", h);

var states = svg.append("svg:g")
    .attr("id", "states");

var circles = svg.append("svg:g")
    .attr("id", "circles");

var cells = svg.append("svg:g")
    .attr("id", "cells");

var circuits = svg.append("svg:g")
    .attr("id", "circuits");

// d3.select("input[type=checkbox]").on("change", function() {
//   cells.classed("voronoi", this.checked);
// });

d3.json("us-states.json", function(collection) {
  states.selectAll("path")
      .data(collection.features)
    .enter().append("svg:path")
      .attr("d", path);
});

var polygons;

var arc = d3.geo.greatArc()
    .source(function(d) { 
	  switch (d.type) {
	  case 'LINK':
		  return locationByDevice[d.source];
		  break;
	  case 'CIRCUIT':
		  return [locationByDevice[d.source][0],locationByDevice[d.source][1]+.1];
		  break
	  }

  })
    .target(function(d) { 
	  switch (d.type) {
	  case 'LINK':
		  return locationByDevice[d.target];
		  break;
	  case 'CIRCUIT':
		  return [locationByDevice[d.target][0],locationByDevice[d.target][1]+.1];
		  break
	  }
  });

var linksByOrigin = {},
    countByDevice = {},
	locationByDevice = {},
	circuitLinksById = {},
    positions = [];

d3.csv("data/traffic.csv", function(flights) {

  flights.forEach(function(flight) {
    var origin = flight.origin,
        destination = flight.destination,
        links = linksByOrigin[origin] || (linksByOrigin[origin] = []);
    links.push({type: 'LINK', source: origin, target: destination});
    countByDevice[origin] = (countByDevice[origin] || 0) + 1;
    countByDevice[destination] = (countByDevice[destination] || 0) + 1;
  });
  
  d3.csv("data/switches.csv", function(netDevices) {

    // Only consider netDevices with at least one flight.
    netDevices = netDevices.filter(function(netDevice) {
      if (countByDevice[netDevice.iata]) {
        var location = [+netDevice.longitude, +netDevice.latitude];
        locationByDevice[netDevice.iata] = location;
        positions.push(projection(location));
        return true;
      }
    });
	
	// netDevices.forEach(function(a) {
	// 	var s=a.iata
	// 	linksByOrigin[a.iata].forEach(function (l) {
	// 		s = s + ',' + l.target
	// 	});
	// 	alert(s);
	// });
	
    // Compute the Voronoi diagram of netDevices' projected positions.
    polygons = d3.geom.voronoi(positions);
	
    var g = cells.selectAll("g")
        .data(netDevices)
      .enter().append("svg:g");

    g.append("svg:path")
        .attr("class", "cell")
        .attr("d", function(d, i) { return "M" + polygons[i].join("L") + "Z"; })
        .on("mouseover", function(d, i) { d3.select("h2 span").text(d.name); });

    g.selectAll("path.arc")
        .data(function(d) { return linksByOrigin[d.iata] || []; })
      .enter().append("svg:path")
        .attr("class", "arc")
        .attr("d", function(d) { return path(arc(d)); });

    circles.selectAll("circle")
        .data(netDevices)
      .enter().append("svg:circle")
        .attr("cx", function(d, i) { return positions[i][0]; })
        .attr("cy", function(d, i) { return positions[i][1]; })
        .attr("r", function(d, i) { 
			return countByDevice[d.iata]*2;
		})
		.style("fill", function(d,i) {
			if (netDevices[i].type == 1) {
				return "red";
			}
			return "blue";
		})
        .sort(function(a, b) { return countByDevice[b.iata] - countByDevice[a.iata]; });
  });
  
  d3.csv("data/circuits.csv", function(circuitLinks) {
	
  	  circuitLinks.forEach(function(circuitLink) {
	      var id          = circuitLink.id,
	          links       = circuitLinksById[id] || (circuitLinksById[id] = []);

	      links.push({
			  type:   'CIRCUIT',
			  hop:    circuitLink.hop,
			  source: circuitLink.src,
			  target: circuitLink.dst,
			  color:  circuitLink.color || ('#fbb')
		  });
	  });
	  
      // Filter circuit IDs
      circuitIDs = circuitLinks.filter(function(circuitLink) {
        if (circuitLink.hop == 1)
          return true;
      });

      var g = circuits.selectAll("g")
          .data(circuitIDs)
        .enter().append("svg:g");

	  g.selectAll("path.arc")
	  		.data(function(d) { return circuitLinksById[d.id] || []; })
	  	.enter().append("svg:path")
			.attr("class", "circuit")
			.style("stroke", function(d) { return d.color; })
			.attr("d", function(d) { return path(arc(d)); });
	  
  });
});
    </script>
  </body>
</html>
